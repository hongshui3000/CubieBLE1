; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave --gnu -o.\objects\epb.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\epb.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 --preinclude=autoconf_app.h -I..\..\..\..\include -I..\..\..\..\arch -I..\..\..\..\include\arch\arm -I..\..\..\..\include\zephyr -I..\..\..\..\include\net -I..\..\..\..\include\shell -I..\..\..\..\include\drivers -I..\..\..\..\kernel\include -I..\..\..\..\arch\soc\atb110x -I..\..\..\..\include\arch\arm\cortex_m\cmsis\Include -I..\..\..\..\lib\libc\minimal\include -I..\..\..\..\include\generated -I..\..\..\..\boards -I..\src\include -I..\..\..\..\subsys\bluetooth -I..\..\..\..\subsys\bluetooth\host -I..\src\profile -I..\..\gatt -I..\..\..\..\subsys\bluetooth\common -I.\RTE\_flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DARMCM0 --omf_browse=.\objects\epb.crf ..\src\wechat\MmBp_Embedded_1.0.4\protobuf\epb.c]
                          THUMB

                          AREA ||i.epb_fixed32_pack_size||, CODE, READONLY, ALIGN=1

                  epb_fixed32_pack_size PROC
;;;398    
;;;399    int epb_fixed32_pack_size(uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;400    {
;;;401        return sizeof_tag(tag) + 4;
000002  f7fffffe          BL       sizeof_tag
000006  1d00              ADDS     r0,r0,#4
;;;402    }
000008  bd10              POP      {r4,pc}
;;;403    
                          ENDP


                          AREA ||i.epb_get_bool||, CODE, READONLY, ALIGN=1

                  epb_get_bool PROC
;;;162    
;;;163    bool epb_get_bool(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;164    {
;;;165        return epb_get_uint32(e, tag);
000002  f7fffffe          BL       epb_get_uint32
000006  2800              CMP      r0,#0
000008  d000              BEQ      |L2.12|
00000a  2001              MOVS     r0,#1
                  |L2.12|
;;;166    }
00000c  bd10              POP      {r4,pc}
;;;167    
                          ENDP


                          AREA ||i.epb_get_bytes||, CODE, READONLY, ALIGN=1

                  epb_get_bytes PROC
;;;172    
;;;173    const uint8_t *epb_get_bytes(Epb *e, uint16_t tag, int *len)
000000  b5f8              PUSH     {r3-r7,lr}
;;;174    {
000002  4616              MOV      r6,r2
000004  460a              MOV      r2,r1
000006  4604              MOV      r4,r0
;;;175        int offset = epb_get_tag_value_offset(e->unpack_buf, e->buf_len, tag);
000008  6881              LDR      r1,[r0,#8]
00000a  6800              LDR      r0,[r0,#0]
00000c  f7fffffe          BL       epb_get_tag_value_offset
000010  0005              MOVS     r5,r0
;;;176        if (offset < 0)
000012  d501              BPL      |L3.24|
;;;177            return NULL;
000014  2000              MOVS     r0,#0
;;;178    
;;;179        uint32_t l;
;;;180        offset += epb_get_varint32_bits(e->unpack_buf+offset, e->buf_len-offset, &l);
;;;181        *len = (int)l;
;;;182    
;;;183        return e->unpack_buf+offset;
;;;184    }
000016  bdf8              POP      {r3-r7,pc}
                  |L3.24|
000018  68a0              LDR      r0,[r4,#8]            ;180
00001a  466a              MOV      r2,sp                 ;180
00001c  1b41              SUBS     r1,r0,r5              ;180
00001e  6820              LDR      r0,[r4,#0]            ;180
000020  1940              ADDS     r0,r0,r5              ;180
000022  f7fffffe          BL       epb_get_varint32_bits
000026  9900              LDR      r1,[sp,#0]            ;181
000028  6031              STR      r1,[r6,#0]            ;183
00002a  6821              LDR      r1,[r4,#0]            ;183
00002c  1940              ADDS     r0,r0,r5              ;180
00002e  1808              ADDS     r0,r1,r0              ;183
000030  bdf8              POP      {r3-r7,pc}
;;;185    
                          ENDP


                          AREA ||i.epb_get_enum||, CODE, READONLY, ALIGN=1

                  epb_get_enum PROC
;;;167    
;;;168    int epb_get_enum(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170        return epb_get_uint32(e, tag);
000002  f7fffffe          BL       epb_get_uint32
;;;171    }
000006  bd10              POP      {r4,pc}
;;;172    
                          ENDP


                          AREA ||i.epb_get_fixed32||, CODE, READONLY, ALIGN=1

                  epb_get_fixed32 PROC
;;;195    
;;;196    uint32_t epb_get_fixed32(Epb *e, uint16_t tag)
000000  b538              PUSH     {r3-r5,lr}
;;;197    {
000002  460a              MOV      r2,r1
000004  4604              MOV      r4,r0
;;;198        int offset = epb_get_tag_value_offset(e->unpack_buf, e->buf_len, tag);
000006  6881              LDR      r1,[r0,#8]
000008  6800              LDR      r0,[r0,#0]
00000a  f7fffffe          BL       epb_get_tag_value_offset
;;;199        if (offset < 0)
00000e  2800              CMP      r0,#0
000010  da01              BGE      |L5.22|
;;;200            return 0;
000012  2000              MOVS     r0,#0
                  |L5.20|
;;;201    
;;;202        return epb_get_fixed32_bits(e->unpack_buf+offset, e->buf_len-offset);
;;;203    }
000014  bd38              POP      {r3-r5,pc}
                  |L5.22|
000016  6821              LDR      r1,[r4,#0]            ;202
000018  68a2              LDR      r2,[r4,#8]            ;202
00001a  1809              ADDS     r1,r1,r0              ;202
00001c  1a12              SUBS     r2,r2,r0              ;202
00001e  2000              MOVS     r0,#0                 ;202
000020  2a04              CMP      r2,#4                 ;202
000022  dbf7              BLT      |L5.20|
000024  9000              STR      r0,[sp,#0]            ;202
000026  2204              MOVS     r2,#4                 ;202
000028  4668              MOV      r0,sp                 ;202
00002a  f7fffffe          BL       __aeabi_memcpy
00002e  9800              LDR      r0,[sp,#0]            ;202
000030  bd38              POP      {r3-r5,pc}
;;;204    
                          ENDP


                          AREA ||i.epb_get_float||, CODE, READONLY, ALIGN=1

                  epb_get_float PROC
;;;209    
;;;210    float epb_get_float(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212        uint32_t bits = epb_get_fixed32(e, tag);
000002  f7fffffe          BL       epb_get_fixed32
;;;213        return *(float *)&bits;
;;;214    }
000006  bd10              POP      {r4,pc}
;;;215    
                          ENDP


                          AREA ||i.epb_get_int32||, CODE, READONLY, ALIGN=1

                  epb_get_int32 PROC
;;;148    
;;;149    int32_t epb_get_int32(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;150    {
;;;151        return epb_get_uint32(e, tag);
000002  f7fffffe          BL       epb_get_uint32
;;;152    }
000006  bd10              POP      {r4,pc}
;;;153    
                          ENDP


                          AREA ||i.epb_get_message||, CODE, READONLY, ALIGN=1

                  epb_get_message PROC
;;;190    
;;;191    const Message *epb_get_message(Epb *e, uint16_t tag, int *len)
000000  b510              PUSH     {r4,lr}
;;;192    {
;;;193        return (Message *)epb_get_bytes(e, tag, len);
000002  f7fffffe          BL       epb_get_bytes
;;;194    }
000006  bd10              POP      {r4,pc}
;;;195    
                          ENDP


                          AREA ||i.epb_get_packed_size||, CODE, READONLY, ALIGN=1

                  epb_get_packed_size PROC
;;;264    
;;;265    int epb_get_packed_size(Epb *e)
000000  68c0              LDR      r0,[r0,#0xc]
;;;266    {
;;;267        return e->buf_offset;
;;;268    }
000002  4770              BX       lr
;;;269    
                          ENDP


                          AREA ||i.epb_get_sfixed32||, CODE, READONLY, ALIGN=1

                  epb_get_sfixed32 PROC
;;;204    
;;;205    int32_t epb_get_sfixed32(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;206    {
;;;207        return epb_get_fixed32(e, tag);
000002  f7fffffe          BL       epb_get_fixed32
;;;208    }
000006  bd10              POP      {r4,pc}
;;;209    
                          ENDP


                          AREA ||i.epb_get_sint32||, CODE, READONLY, ALIGN=1

                  epb_get_sint32 PROC
;;;153    
;;;154    int32_t epb_get_sint32(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;155    {
;;;156        uint32_t value = epb_get_uint32(e, tag);
000002  f7fffffe          BL       epb_get_uint32
;;;157        if (value&1)
000006  07c1              LSLS     r1,r0,#31
000008  d002              BEQ      |L11.16|
;;;158            return -(value>>1) - 1;
00000a  0840              LSRS     r0,r0,#1
00000c  43c0              MVNS     r0,r0
;;;159        else
;;;160            return value>>1;
;;;161    }
00000e  bd10              POP      {r4,pc}
                  |L11.16|
000010  0840              LSRS     r0,r0,#1              ;160
000012  bd10              POP      {r4,pc}
;;;162    
                          ENDP


                          AREA ||i.epb_get_string||, CODE, READONLY, ALIGN=1

                  epb_get_string PROC
;;;185    
;;;186    const char *epb_get_string(Epb *e, uint16_t tag, int *len)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188        return (char *)epb_get_bytes(e, tag, len);
000002  f7fffffe          BL       epb_get_bytes
;;;189    }
000006  bd10              POP      {r4,pc}
;;;190    
                          ENDP


                          AREA ||i.epb_get_tag_value_offset||, CODE, READONLY, ALIGN=1

                  epb_get_tag_value_offset PROC
;;;66     
;;;67     static int epb_get_tag_value_offset(const uint8_t *data, int len, uint16_t tag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;68     {
000002  4617              MOV      r7,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;69         int offset = 0;
000008  2400              MOVS     r4,#0
00000a  e03f              B        |L13.140|
                  |L13.12|
;;;70         uint32_t p_tag;
;;;71         while (offset < len) {
;;;72             p_tag = data[offset++];
00000c  5d28              LDRB     r0,[r5,r4]
;;;73             while ((data[offset-1]&CONTINUOUS_MASK)!=0 && offset<len) {
00000e  e004              B        |L13.26|
                  |L13.16|
;;;74                 p_tag = (p_tag<<8)|(data[offset++]&0x7f); //TODO:Tag more then two bytes
000010  5d29              LDRB     r1,[r5,r4]
000012  0200              LSLS     r0,r0,#8
000014  0649              LSLS     r1,r1,#25
000016  0e49              LSRS     r1,r1,#25
000018  4308              ORRS     r0,r0,r1
                  |L13.26|
00001a  1c64              ADDS     r4,r4,#1
00001c  1929              ADDS     r1,r5,r4              ;73
00001e  3920              SUBS     r1,r1,#0x20           ;73
000020  7fc9              LDRB     r1,[r1,#0x1f]         ;73
000022  0609              LSLS     r1,r1,#24             ;73
000024  d501              BPL      |L13.42|
000026  42b4              CMP      r4,r6                 ;73
000028  dbf2              BLT      |L13.16|
                  |L13.42|
;;;75             }
;;;76             if (p_tag == tag)
00002a  42b8              CMP      r0,r7
00002c  d101              BNE      |L13.50|
;;;77                 return offset;
00002e  4620              MOV      r0,r4
;;;78     
;;;79             uint32_t wire_type = epb_get_wire_type(p_tag);
;;;80             int ret = epb_get_value_length(data+offset, len-offset, wire_type);
;;;81             if (ret < 0) {
;;;82                 offset++;
;;;83                 continue;
;;;84             }
;;;85     
;;;86             offset += ret;
;;;87         }
;;;88         return -1;
;;;89     }
000030  bdf8              POP      {r3-r7,pc}
                  |L13.50|
000032  b280              UXTH     r0,r0                 ;79
000034  0742              LSLS     r2,r0,#29             ;79
000036  0f52              LSRS     r2,r2,#29             ;79
000038  0a01              LSRS     r1,r0,#8              ;79
00003a  d001              BEQ      |L13.64|
00003c  0540              LSLS     r0,r0,#21             ;79
00003e  0f42              LSRS     r2,r0,#29             ;79
                  |L13.64|
000040  192b              ADDS     r3,r5,r4              ;80
000042  1b31              SUBS     r1,r6,r4              ;80
000044  2000              MOVS     r0,#0                 ;80
000046  2a00              CMP      r2,#0                 ;80
000048  d00a              BEQ      |L13.96|
00004a  2a01              CMP      r2,#1                 ;80
00004c  d010              BEQ      |L13.112|
00004e  2a02              CMP      r2,#2                 ;80
000050  d010              BEQ      |L13.116|
000052  2a05              CMP      r2,#5                 ;80
000054  d017              BEQ      |L13.134|
000056  1e40              SUBS     r0,r0,#1              ;80
                  |L13.88|
000058  2800              CMP      r0,#0                 ;81
00005a  da16              BGE      |L13.138|
00005c  1c64              ADDS     r4,r4,#1              ;81
00005e  e015              B        |L13.140|
                  |L13.96|
000060  5c1a              LDRB     r2,[r3,r0]            ;83
000062  1c40              ADDS     r0,r0,#1              ;83
000064  0612              LSLS     r2,r2,#24             ;83
000066  2a00              CMP      r2,#0                 ;83
000068  daf6              BGE      |L13.88|
00006a  4288              CMP      r0,r1                 ;83
00006c  dbf8              BLT      |L13.96|
00006e  e7f3              B        |L13.88|
                  |L13.112|
000070  2008              MOVS     r0,#8                 ;83
000072  e7f1              B        |L13.88|
                  |L13.116|
000074  2000              MOVS     r0,#0                 ;83
000076  9000              STR      r0,[sp,#0]            ;83
000078  4618              MOV      r0,r3                 ;83
00007a  466a              MOV      r2,sp                 ;83
00007c  f7fffffe          BL       epb_get_varint32_bits
000080  9900              LDR      r1,[sp,#0]            ;83
000082  1840              ADDS     r0,r0,r1              ;83
000084  e7e8              B        |L13.88|
                  |L13.134|
000086  2004              MOVS     r0,#4                 ;83
000088  e7e6              B        |L13.88|
                  |L13.138|
00008a  1824              ADDS     r4,r4,r0              ;86
                  |L13.140|
00008c  42b4              CMP      r4,r6                 ;71
00008e  dbbd              BLT      |L13.12|
000090  2000              MOVS     r0,#0                 ;88
000092  43c0              MVNS     r0,r0                 ;88
000094  bdf8              POP      {r3-r7,pc}
;;;90     
                          ENDP


                          AREA ||i.epb_get_uint32||, CODE, READONLY, ALIGN=1

                  epb_get_uint32 PROC
;;;137    
;;;138    uint32_t epb_get_uint32(Epb *e, uint16_t tag)
000000  b538              PUSH     {r3-r5,lr}
;;;139    {
000002  460a              MOV      r2,r1
000004  4604              MOV      r4,r0
;;;140        int offset = epb_get_tag_value_offset(e->unpack_buf, e->buf_len, tag);
000006  6881              LDR      r1,[r0,#8]
000008  6800              LDR      r0,[r0,#0]
00000a  f7fffffe          BL       epb_get_tag_value_offset
;;;141        if (offset < 0)
00000e  2800              CMP      r0,#0
000010  da01              BGE      |L14.22|
;;;142            return 0;
000012  2000              MOVS     r0,#0
;;;143    
;;;144        uint32_t value = 0;
;;;145        epb_get_varint32_bits(e->unpack_buf+offset, e->buf_len-offset, &value);
;;;146        return value;
;;;147    }
000014  bd38              POP      {r3-r5,pc}
                  |L14.22|
000016  2100              MOVS     r1,#0                 ;144
000018  9100              STR      r1,[sp,#0]            ;145
00001a  68a1              LDR      r1,[r4,#8]            ;145
00001c  6822              LDR      r2,[r4,#0]            ;145
00001e  1a09              SUBS     r1,r1,r0              ;145
000020  1810              ADDS     r0,r2,r0              ;145
000022  466a              MOV      r2,sp                 ;145
000024  f7fffffe          BL       epb_get_varint32_bits
000028  9800              LDR      r0,[sp,#0]            ;146
00002a  bd38              POP      {r3-r5,pc}
;;;148    
                          ENDP


                          AREA ||i.epb_get_varint32_bits||, CODE, READONLY, ALIGN=1

                  epb_get_varint32_bits PROC
;;;90     
;;;91     static int epb_get_varint32_bits(const uint8_t *data, int len, uint32_t *value)
000000  b570              PUSH     {r4-r6,lr}
;;;92     {
000002  4604              MOV      r4,r0
;;;93         int offset = 0;
;;;94         uint32_t p_value = data[offset++] & 0x7F;
000004  7800              LDRB     r0,[r0,#0]
000006  0643              LSLS     r3,r0,#25
000008  0e5b              LSRS     r3,r3,#25
00000a  2001              MOVS     r0,#1
00000c  e00e              B        |L15.44|
                  |L15.14|
;;;95         while ((data[offset-1]&CONTINUOUS_MASK) != 0) {
;;;96             if (offset >= len)
00000e  4288              CMP      r0,r1
000010  db02              BLT      |L15.24|
;;;97                 return -1;
000012  2000              MOVS     r0,#0
000014  43c0              MVNS     r0,r0
;;;98     
;;;99             if (offset >= 5)
;;;100                break;
;;;101    
;;;102            p_value |= ((uint32_t)data[offset]&0x7F) << (offset*7);
;;;103            ++offset;
;;;104        }
;;;105        *value = p_value;
;;;106        return offset;
;;;107    }
000016  bd70              POP      {r4-r6,pc}
                  |L15.24|
000018  2805              CMP      r0,#5                 ;99
00001a  da0c              BGE      |L15.54|
00001c  5c25              LDRB     r5,[r4,r0]            ;102
00001e  00c6              LSLS     r6,r0,#3              ;102
000020  066d              LSLS     r5,r5,#25             ;102
000022  0e6d              LSRS     r5,r5,#25             ;102
000024  1a36              SUBS     r6,r6,r0              ;102
000026  40b5              LSLS     r5,r5,r6              ;102
000028  432b              ORRS     r3,r3,r5              ;102
00002a  1c40              ADDS     r0,r0,#1              ;102
                  |L15.44|
00002c  1825              ADDS     r5,r4,r0              ;95
00002e  3d20              SUBS     r5,r5,#0x20           ;95
000030  7fed              LDRB     r5,[r5,#0x1f]         ;95
000032  062d              LSLS     r5,r5,#24             ;95
000034  d4eb              BMI      |L15.14|
                  |L15.54|
000036  6013              STR      r3,[r2,#0]            ;105
000038  bd70              POP      {r4-r6,pc}
;;;108    
                          ENDP


                          AREA ||i.epb_has_tag||, CODE, READONLY, ALIGN=1

                  epb_has_tag PROC
;;;128    
;;;129    bool epb_has_tag(Epb *e, uint16_t tag)
000000  b510              PUSH     {r4,lr}
;;;130    {
000002  460a              MOV      r2,r1
;;;131        int offset = epb_get_tag_value_offset(e->unpack_buf, e->buf_len, tag);
000004  6881              LDR      r1,[r0,#8]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       epb_get_tag_value_offset
;;;132        if (offset < 0)
00000c  2800              CMP      r0,#0
00000e  da01              BGE      |L16.20|
;;;133            return false;
000010  2000              MOVS     r0,#0
;;;134        else
;;;135            return true;
;;;136    }
000012  bd10              POP      {r4,pc}
                  |L16.20|
000014  2001              MOVS     r0,#1                 ;135
000016  bd10              POP      {r4,pc}
;;;137    
                          ENDP


                          AREA ||i.epb_length_delimited_pack_size||, CODE, READONLY, ALIGN=1

                  epb_length_delimited_pack_size PROC
;;;403    
;;;404    int epb_length_delimited_pack_size(uint16_t tag, int len)
000000  b510              PUSH     {r4,lr}
;;;405    {
000002  460c              MOV      r4,r1
;;;406        return epb_varint32_pack_size(tag, len, false) + len;
000004  2200              MOVS     r2,#0
000006  f7fffffe          BL       epb_varint32_pack_size
00000a  1900              ADDS     r0,r0,r4
;;;407    }
00000c  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.epb_pack_init||, CODE, READONLY, ALIGN=1

                  epb_pack_init PROC
;;;257    
;;;258    void epb_pack_init(Epb *e, uint8_t *buf, int len)
000000  6082              STR      r2,[r0,#8]
;;;259    {
;;;260        e->pack_buf = buf;
;;;261        e->buf_len = len;
;;;262        e->buf_offset = 0;
000002  6041              STR      r1,[r0,#4]
000004  2100              MOVS     r1,#0
000006  60c1              STR      r1,[r0,#0xc]
;;;263    }
000008  4770              BX       lr
;;;264    
                          ENDP


                          AREA ||i.epb_pack_tag||, CODE, READONLY, ALIGN=1

                  epb_pack_tag PROC
;;;224    
;;;225    static int epb_pack_tag(Epb *e, uint16_t tag)
000000  b570              PUSH     {r4-r6,lr}
;;;226    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;227        int tag_len = sizeof_tag(tag);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       sizeof_tag
00000c  4602              MOV      r2,r0
00000e  68a1              LDR      r1,[r4,#8]
000010  68e0              LDR      r0,[r4,#0xc]
000012  1a09              SUBS     r1,r1,r0
;;;228        if (epb_pack_buf_remain(e) >= tag_len) {
000014  4291              CMP      r1,r2
000016  db0c              BLT      |L19.50|
;;;229            uint8_t *buf = e->pack_buf + e->buf_offset;
000018  6861              LDR      r1,[r4,#4]
00001a  1808              ADDS     r0,r1,r0
;;;230            if (tag_len == 2) //TODO
00001c  2a02              CMP      r2,#2
00001e  d102              BNE      |L19.38|
;;;231                *(buf++) = 0xff&(tag>>8);
000020  0a29              LSRS     r1,r5,#8
000022  7001              STRB     r1,[r0,#0]
000024  1c40              ADDS     r0,r0,#1
                  |L19.38|
;;;232            *buf = 0xff&tag;
000026  7005              STRB     r5,[r0,#0]
;;;233            e->buf_offset += tag_len;
000028  68e0              LDR      r0,[r4,#0xc]
00002a  1880              ADDS     r0,r0,r2
;;;234            return tag_len;
00002c  60e0              STR      r0,[r4,#0xc]
00002e  4610              MOV      r0,r2
;;;235        }
;;;236        return -1;
;;;237    }
000030  bd70              POP      {r4-r6,pc}
                  |L19.50|
000032  2000              MOVS     r0,#0                 ;236
000034  43c0              MVNS     r0,r0                 ;236
000036  bd70              POP      {r4-r6,pc}
;;;238    
                          ENDP


                          AREA ||i.epb_pack_varint32_bits||, CODE, READONLY, ALIGN=1

                  epb_pack_varint32_bits PROC
;;;238    
;;;239    static int epb_pack_varint32_bits(Epb *e, uint32_t value)
000000  b57c              PUSH     {r2-r6,lr}
;;;240    {
000002  4605              MOV      r5,r0
;;;241        uint8_t buf[5] = {0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;242        int i = 0;
000008  4604              MOV      r4,r0
00000a  466a              MOV      r2,sp                 ;241
;;;243        do {
;;;244            buf[i] = value&0x7f;
;;;245            if (i-1 >= 0)
;;;246                buf[i-1] |= 0x80;
00000c  2680              MOVS     r6,#0x80
00000e  9001              STR      r0,[sp,#4]
                  |L20.16|
000010  0648              LSLS     r0,r1,#25             ;244
000012  0e40              LSRS     r0,r0,#25             ;244
000014  5510              STRB     r0,[r2,r4]            ;244
000016  2c01              CMP      r4,#1                 ;245
000018  d404              BMI      |L20.36|
00001a  1910              ADDS     r0,r2,r4
00001c  3820              SUBS     r0,r0,#0x20
00001e  7fc3              LDRB     r3,[r0,#0x1f]
000020  4333              ORRS     r3,r3,r6
000022  77c3              STRB     r3,[r0,#0x1f]
                  |L20.36|
;;;247            value = value >> 7;
000024  09c9              LSRS     r1,r1,#7
000026  1c64              ADDS     r4,r4,#1
;;;248            ++i;
;;;249        } while (value!=0 && i<5);
000028  2900              CMP      r1,#0
00002a  d001              BEQ      |L20.48|
00002c  2c05              CMP      r4,#5
00002e  dbef              BLT      |L20.16|
                  |L20.48|
000030  68a9              LDR      r1,[r5,#8]
000032  68e8              LDR      r0,[r5,#0xc]
000034  1a09              SUBS     r1,r1,r0
;;;250        if (epb_pack_buf_remain(e) >= i) {
000036  42a1              CMP      r1,r4
000038  db0a              BLT      |L20.80|
;;;251            memcpy(e->pack_buf+e->buf_offset, buf, i);
00003a  6869              LDR      r1,[r5,#4]
00003c  4622              MOV      r2,r4
00003e  1808              ADDS     r0,r1,r0
000040  4669              MOV      r1,sp
000042  f7fffffe          BL       __aeabi_memcpy
;;;252            e->buf_offset += i;
000046  68e8              LDR      r0,[r5,#0xc]
000048  1900              ADDS     r0,r0,r4
;;;253            return i;
00004a  60e8              STR      r0,[r5,#0xc]
00004c  4620              MOV      r0,r4
;;;254        }
;;;255        return -1;
;;;256    }
00004e  bd7c              POP      {r2-r6,pc}
                  |L20.80|
000050  2000              MOVS     r0,#0                 ;255
000052  43c0              MVNS     r0,r0                 ;255
000054  bd7c              POP      {r2-r6,pc}
;;;257    
                          ENDP


                          AREA ||i.epb_set_bool||, CODE, READONLY, ALIGN=1

                  epb_set_bool PROC
;;;294    
;;;295    int epb_set_bool(Epb *e, uint16_t tag, bool value)
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297        return epb_set_uint32(e, tag, value);
000002  f7fffffe          BL       epb_set_uint32
;;;298    }
000006  bd10              POP      {r4,pc}
;;;299    
                          ENDP


                          AREA ||i.epb_set_bytes||, CODE, READONLY, ALIGN=1

                  epb_set_bytes PROC
;;;331    
;;;332    int epb_set_bytes(Epb *e, uint16_t tag, const uint8_t *data, int length)
000000  b5f8              PUSH     {r3-r7,lr}
;;;333    {
000002  461d              MOV      r5,r3
000004  4617              MOV      r7,r2
000006  4604              MOV      r4,r0
;;;334        int len = 0;
;;;335        int ret = epb_pack_tag(e, tag);
000008  f7fffffe          BL       epb_pack_tag
;;;336        if (ret < 0) return ret;
00000c  2800              CMP      r0,#0
00000e  db1c              BLT      |L22.74|
;;;337        len += ret;
000010  4606              MOV      r6,r0
;;;338    
;;;339        ret = epb_pack_varint32_bits(e, length);
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       epb_pack_varint32_bits
;;;340        if (ret < 0) return ret;
00001a  2800              CMP      r0,#0
00001c  db15              BLT      |L22.74|
;;;341        len += ret;
00001e  1836              ADDS     r6,r6,r0
000020  68a2              LDR      r2,[r4,#8]
000022  68e0              LDR      r0,[r4,#0xc]
;;;342    
;;;343        ret = epb_pack_length_delimited(e, data, length);
000024  4639              MOV      r1,r7
000026  1a12              SUBS     r2,r2,r0
000028  42aa              CMP      r2,r5
00002a  db09              BLT      |L22.64|
00002c  6862              LDR      r2,[r4,#4]
00002e  1810              ADDS     r0,r2,r0
000030  462a              MOV      r2,r5
000032  f7fffffe          BL       __aeabi_memcpy
000036  68e0              LDR      r0,[r4,#0xc]
000038  1940              ADDS     r0,r0,r5
00003a  60e0              STR      r0,[r4,#0xc]
00003c  4628              MOV      r0,r5
00003e  e001              B        |L22.68|
                  |L22.64|
000040  2000              MOVS     r0,#0
000042  43c0              MVNS     r0,r0
                  |L22.68|
;;;344        if (ret < 0) return ret;
000044  2800              CMP      r0,#0
000046  db00              BLT      |L22.74|
;;;345        len += ret;
000048  1830              ADDS     r0,r6,r0
                  |L22.74|
;;;346    
;;;347        return len;
;;;348    }
00004a  bdf8              POP      {r3-r7,pc}
;;;349    
                          ENDP


                          AREA ||i.epb_set_enum||, CODE, READONLY, ALIGN=1

                  epb_set_enum PROC
;;;299    
;;;300    int epb_set_enum(Epb *e, uint16_t tag, int value)
000000  b510              PUSH     {r4,lr}
;;;301    {
;;;302        return epb_set_uint32(e, tag, value);
000002  f7fffffe          BL       epb_set_uint32
;;;303    }
000006  bd10              POP      {r4,pc}
;;;304    
                          ENDP


                          AREA ||i.epb_set_fixed32||, CODE, READONLY, ALIGN=1

                  epb_set_fixed32 PROC
;;;359    
;;;360    int epb_set_fixed32(Epb *e, uint16_t tag, uint32_t value)
000000  b5f8              PUSH     {r3-r7,lr}
;;;361    {
000002  4616              MOV      r6,r2
000004  4604              MOV      r4,r0
;;;362        int len = 0;
;;;363        int ret = epb_pack_tag(e, tag);
000006  f7fffffe          BL       epb_pack_tag
;;;364        if (ret < 0) return ret;
00000a  2800              CMP      r0,#0
00000c  db16              BLT      |L24.60|
00000e  9600              STR      r6,[sp,#0]
;;;365        len += ret;
000010  4605              MOV      r5,r0
000012  68a1              LDR      r1,[r4,#8]
000014  68e0              LDR      r0,[r4,#0xc]
000016  1a09              SUBS     r1,r1,r0
000018  2904              CMP      r1,#4
00001a  db0a              BLT      |L24.50|
00001c  6861              LDR      r1,[r4,#4]
00001e  2204              MOVS     r2,#4
000020  1808              ADDS     r0,r1,r0
000022  4669              MOV      r1,sp
000024  f7fffffe          BL       __aeabi_memcpy
000028  68e0              LDR      r0,[r4,#0xc]
00002a  1d00              ADDS     r0,r0,#4
00002c  60e0              STR      r0,[r4,#0xc]
00002e  2004              MOVS     r0,#4
000030  e001              B        |L24.54|
                  |L24.50|
000032  2000              MOVS     r0,#0
000034  43c0              MVNS     r0,r0
                  |L24.54|
;;;366    
;;;367        ret = epb_set_fixed32_bits(e, value);
;;;368        if (ret < 0) return ret;
000036  2800              CMP      r0,#0
000038  db00              BLT      |L24.60|
;;;369        len += ret;
00003a  1828              ADDS     r0,r5,r0
                  |L24.60|
;;;370    
;;;371        return len;
;;;372    }
00003c  bdf8              POP      {r3-r7,pc}
;;;373    
                          ENDP


                          AREA ||i.epb_set_float||, CODE, READONLY, ALIGN=1

                  epb_set_float PROC
;;;378    
;;;379    int epb_set_float(Epb *e, uint16_t tag, float value)
000000  b510              PUSH     {r4,lr}
;;;380    {
;;;381        uint32_t v = *(uint32_t *)&value;
;;;382        return epb_set_fixed32(e, tag, v);
000002  f7fffffe          BL       epb_set_fixed32
;;;383    }
000006  bd10              POP      {r4,pc}
;;;384    
                          ENDP


                          AREA ||i.epb_set_int32||, CODE, READONLY, ALIGN=1

                  epb_set_int32 PROC
;;;283    
;;;284    int epb_set_int32(Epb *e, uint16_t tag, int32_t value)
000000  b510              PUSH     {r4,lr}
;;;285    {
;;;286        return epb_set_uint32(e, tag, value);
000002  f7fffffe          BL       epb_set_uint32
;;;287    }
000006  bd10              POP      {r4,pc}
;;;288    
                          ENDP


                          AREA ||i.epb_set_message||, CODE, READONLY, ALIGN=1

                  epb_set_message PROC
;;;354    
;;;355    int epb_set_message(Epb *e, uint16_t tag, const Message *data, int len)
000000  b510              PUSH     {r4,lr}
;;;356    {
;;;357        return epb_set_bytes(e, tag, data, len);
000002  f7fffffe          BL       epb_set_bytes
;;;358    }
000006  bd10              POP      {r4,pc}
;;;359    
                          ENDP


                          AREA ||i.epb_set_sfixed32||, CODE, READONLY, ALIGN=1

                  epb_set_sfixed32 PROC
;;;373    
;;;374    int epb_set_sfixed32(Epb *e, uint16_t tag, int32_t value)
000000  b510              PUSH     {r4,lr}
;;;375    {
;;;376        return epb_set_fixed32(e, tag, value);
000002  f7fffffe          BL       epb_set_fixed32
;;;377    }
000006  bd10              POP      {r4,pc}
;;;378    
                          ENDP


                          AREA ||i.epb_set_sint32||, CODE, READONLY, ALIGN=1

                  epb_set_sint32 PROC
;;;288    
;;;289    int epb_set_sint32(Epb *e, uint16_t tag, int32_t value)
000000  0053              LSLS     r3,r2,#1
;;;290    {
000002  b510              PUSH     {r4,lr}
;;;291        uint32_t v = (value << 1) ^ (value >> 31);
000004  17d2              ASRS     r2,r2,#31
000006  405a              EORS     r2,r2,r3
;;;292        return epb_set_uint32(e, tag, v);
000008  f7fffffe          BL       epb_set_uint32
;;;293    }
00000c  bd10              POP      {r4,pc}
;;;294    
                          ENDP


                          AREA ||i.epb_set_string||, CODE, READONLY, ALIGN=1

                  epb_set_string PROC
;;;349    
;;;350    int epb_set_string(Epb *e, uint16_t tag, const char *data, int len)
000000  b510              PUSH     {r4,lr}
;;;351    {
;;;352        return epb_set_bytes(e, tag, (const uint8_t *)data, len);
000002  f7fffffe          BL       epb_set_bytes
;;;353    }
000006  bd10              POP      {r4,pc}
;;;354    
                          ENDP


                          AREA ||i.epb_set_uint32||, CODE, READONLY, ALIGN=1

                  epb_set_uint32 PROC
;;;269    
;;;270    int epb_set_uint32(Epb *e, uint16_t tag, uint32_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;271    {
000002  4615              MOV      r5,r2
000004  4606              MOV      r6,r0
;;;272        int len = 0;
;;;273        int ret = epb_pack_tag(e, tag);
000006  f7fffffe          BL       epb_pack_tag
;;;274        if (ret < 0) return ret;
00000a  2800              CMP      r0,#0
00000c  db07              BLT      |L31.30|
;;;275        len += ret;
00000e  4604              MOV      r4,r0
;;;276    
;;;277        ret = epb_pack_varint32_bits(e, value);
000010  4629              MOV      r1,r5
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       epb_pack_varint32_bits
;;;278        if (ret < 0) return ret;
000018  2800              CMP      r0,#0
00001a  db00              BLT      |L31.30|
;;;279        len += ret;
00001c  1820              ADDS     r0,r4,r0
                  |L31.30|
;;;280    
;;;281        return len;
;;;282    }
00001e  bd70              POP      {r4-r6,pc}
;;;283    
                          ENDP


                          AREA ||i.epb_unpack_init||, CODE, READONLY, ALIGN=1

                  epb_unpack_init PROC
;;;122    
;;;123    void epb_unpack_init(Epb *e, const uint8_t *buf, int len)
000000  6082              STR      r2,[r0,#8]
;;;124    {
;;;125        e->unpack_buf = buf;
;;;126        e->buf_len = len;
000002  6001              STR      r1,[r0,#0]
;;;127    }
000004  4770              BX       lr
;;;128    
                          ENDP


                          AREA ||i.epb_varint32_pack_size||, CODE, READONLY, ALIGN=1

                  epb_varint32_pack_size PROC
;;;384    
;;;385    int epb_varint32_pack_size(uint16_t tag, uint32_t value, bool is_signed)
000000  b510              PUSH     {r4,lr}
;;;386    {
;;;387        if (is_signed)
000002  2a00              CMP      r2,#0
000004  d001              BEQ      |L33.10|
;;;388            value = (value << 1) ^ (value >> 31);
000006  221f              MOVS     r2,#0x1f
000008  41d1              RORS     r1,r1,r2
                  |L33.10|
;;;389    
;;;390        int i = 0;
00000a  2400              MOVS     r4,#0
                  |L33.12|
;;;391        do {
;;;392            value = value >> 7;
00000c  09c9              LSRS     r1,r1,#7
00000e  1c64              ADDS     r4,r4,#1
;;;393            ++i;
;;;394        } while (value!=0 && i<5);
000010  2900              CMP      r1,#0
000012  d001              BEQ      |L33.24|
000014  2c05              CMP      r4,#5
000016  dbf9              BLT      |L33.12|
                  |L33.24|
;;;395    
;;;396        return sizeof_tag(tag) + i;
000018  f7fffffe          BL       sizeof_tag
00001c  1900              ADDS     r0,r0,r4
;;;397    }
00001e  bd10              POP      {r4,pc}
;;;398    
                          ENDP


                          AREA ||i.sizeof_tag||, CODE, READONLY, ALIGN=1

                  sizeof_tag PROC
;;;27     
;;;28     inline static int sizeof_tag(uint16_t tag)
000000  0a00              LSRS     r0,r0,#8
;;;29     {
000002  d001              BEQ      |L34.8|
;;;30         return ((tag&0xff00) == 0) ? 1 : 2; //TODO:Tag more then two bytes
000004  2002              MOVS     r0,#2
;;;31     }
000006  4770              BX       lr
                  |L34.8|
000008  2001              MOVS     r0,#1                 ;30
00000a  4770              BX       lr
;;;32     
                          ENDP

