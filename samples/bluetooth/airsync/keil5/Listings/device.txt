; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave --gnu -o.\objects\device.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\device.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 --preinclude=autoconf_app.h -I..\..\..\..\include -I..\..\..\..\arch -I..\..\..\..\include\arch\arm -I..\..\..\..\include\zephyr -I..\..\..\..\include\net -I..\..\..\..\include\shell -I..\..\..\..\include\drivers -I..\..\..\..\kernel\include -I..\..\..\..\arch\soc\atb110x -I..\..\..\..\include\arch\arm\cortex_m\cmsis\Include -I..\..\..\..\lib\libc\minimal\include -I..\..\..\..\include\generated -I..\..\..\..\boards -I..\src\include -I..\..\..\..\subsys\bluetooth -I..\..\..\..\subsys\bluetooth\host -I..\src\profile -I..\..\gatt -I..\..\..\..\subsys\bluetooth\common -I.\RTE\_flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DARMCM0 --omf_browse=.\objects\device.crf ..\..\..\..\kernel\device.c]
                          THUMB

                          AREA ||i._sys_device_do_config_level||, CODE, READONLY, ALIGN=2

                  _sys_device_do_config_level PROC
;;;36      */
;;;37     void _sys_device_do_config_level(int level)
000000  b570              PUSH     {r4-r6,lr}
;;;38     {
;;;39     	struct device *info;
;;;40     
;;;41     	for (info = config_levels[level]; info < config_levels[level+1];
000002  4907              LDR      r1,|L1.32|
000004  0080              LSLS     r0,r0,#2
000006  580c              LDR      r4,[r1,r0]
000008  1845              ADDS     r5,r0,r1
00000a  e004              B        |L1.22|
                  |L1.12|
;;;42     								info++) {
;;;43     		struct device_config *device = info->config;
;;;44     
;;;45     		device->init(info);
00000c  6820              LDR      r0,[r4,#0]
00000e  6841              LDR      r1,[r0,#4]
000010  4620              MOV      r0,r4
000012  4788              BLX      r1
000014  340c              ADDS     r4,r4,#0xc
                  |L1.22|
000016  6868              LDR      r0,[r5,#4]            ;41
000018  42a0              CMP      r0,r4                 ;41
00001a  d8f7              BHI      |L1.12|
;;;46     	}
;;;47     }
00001c  bd70              POP      {r4-r6,pc}
;;;48     
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.device_any_busy_check||, CODE, READONLY, ALIGN=2

                  device_any_busy_check PROC
;;;111    
;;;112    int device_any_busy_check(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114    	int i = 0;
000002  2400              MOVS     r4,#0
                  |L2.4|
;;;115    
;;;116    	for (i = 0; i < DEVICE_NUM_MAX; i++) {
;;;117    		if (atomic_test_bit((const atomic_t *)device_busy, i))
000004  4809              LDR      r0,|L2.44|
000006  0961              LSRS     r1,r4,#5
000008  0089              LSLS     r1,r1,#2
00000a  1808              ADDS     r0,r1,r0
00000c  f7fffffe          BL       atomic_get
000010  06e1              LSLS     r1,r4,#27
000012  0ec9              LSRS     r1,r1,#27
000014  4108              ASRS     r0,r0,r1
000016  07c0              LSLS     r0,r0,#31
000018  0fc0              LSRS     r0,r0,#31
00001a  d002              BEQ      |L2.34|
;;;118    		return -EBUSY;
00001c  200f              MOVS     r0,#0xf
00001e  43c0              MVNS     r0,r0
;;;119    	}
;;;120    
;;;121    	return 0;
;;;122    }
000020  bd10              POP      {r4,pc}
                  |L2.34|
000022  1c64              ADDS     r4,r4,#1
000024  2c40              CMP      r4,#0x40              ;116
000026  dbed              BLT      |L2.4|
000028  2000              MOVS     r0,#0                 ;121
00002a  bd10              POP      {r4,pc}
                          ENDP

                  |L2.44|
                          DCD      ||.device_BUSY||

                          AREA ||i.device_busy_clear_new||, CODE, READONLY, ALIGN=2

                  device_busy_clear_new PROC
;;;102    
;;;103    void device_busy_clear_new(struct device *busy_dev)
000000  4909              LDR      r1,|L3.40|
;;;104    {
000002  b510              PUSH     {r4,lr}
;;;105    	atomic_clear_bit((atomic_t *) device_busy,
000004  1a40              SUBS     r0,r0,r1
000006  4c07              LDR      r4,|L3.36|
000008  210c              MOVS     r1,#0xc
00000a  f7fffffe          BL       __aeabi_idivmod
00000e  06c2              LSLS     r2,r0,#27
000010  0ed2              LSRS     r2,r2,#27
000012  2101              MOVS     r1,#1
000014  4091              LSLS     r1,r1,r2
000016  0940              LSRS     r0,r0,#5
000018  0080              LSLS     r0,r0,#2
00001a  1900              ADDS     r0,r0,r4
00001c  43c9              MVNS     r1,r1
00001e  f7fffffe          BL       atomic_and
;;;106    				 (busy_dev - Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base));
;;;107    }
000022  bd10              POP      {r4,pc}
;;;108    
                          ENDP

                  |L3.36|
                          DCD      ||.device_BUSY||
                  |L3.40|
                          DCD      ||Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base||

                          AREA ||i.device_busy_set_new||, CODE, READONLY, ALIGN=2

                  device_busy_set_new PROC
;;;96     
;;;97     void device_busy_set_new(struct device *busy_dev)
000000  4909              LDR      r1,|L4.40|
;;;98     {
000002  b510              PUSH     {r4,lr}
;;;99     	atomic_set_bit((atomic_t *) device_busy,
000004  1a40              SUBS     r0,r0,r1
000006  4c07              LDR      r4,|L4.36|
000008  210c              MOVS     r1,#0xc
00000a  f7fffffe          BL       __aeabi_idivmod
00000e  06c2              LSLS     r2,r0,#27
000010  0ed2              LSRS     r2,r2,#27
000012  2101              MOVS     r1,#1
000014  4091              LSLS     r1,r1,r2
000016  0940              LSRS     r0,r0,#5
000018  0080              LSLS     r0,r0,#2
00001a  1900              ADDS     r0,r0,r4
00001c  f7fffffe          BL       atomic_or
;;;100    				 (busy_dev - Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base));
;;;101    }
000020  bd10              POP      {r4,pc}
;;;102    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      ||.device_BUSY||
                  |L4.40|
                          DCD      ||Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base||

                          AREA ||i.device_get_binding||, CODE, READONLY, ALIGN=2

                  device_get_binding PROC
;;;48     
;;;49     struct device *device_get_binding(const char *name)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4606              MOV      r6,r0
;;;51     	struct device *info;
;;;52     
;;;53     	for (info = Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base;
000004  4c09              LDR      r4,|L5.44|
;;;54     				info != Image$$RW_IRAM_DEVICE_APPLICATION$$Limit; info++) {
000006  4d0a              LDR      r5,|L5.48|
000008  e00a              B        |L5.32|
                  |L5.10|
;;;55     		if (info->driver_api && !strcmp(name, info->config->name))
00000a  6860              LDR      r0,[r4,#4]
00000c  2800              CMP      r0,#0
00000e  d006              BEQ      |L5.30|
000010  6820              LDR      r0,[r4,#0]
000012  6801              LDR      r1,[r0,#0]
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       strcmp
00001a  2800              CMP      r0,#0
00001c  d004              BEQ      |L5.40|
                  |L5.30|
00001e  340c              ADDS     r4,r4,#0xc
                  |L5.32|
000020  42ac              CMP      r4,r5                 ;54
000022  d1f2              BNE      |L5.10|
;;;56     			return info;
;;;57     	}
;;;58     
;;;59     	return NULL;
000024  2000              MOVS     r0,#0
;;;60     }
000026  bd70              POP      {r4-r6,pc}
                  |L5.40|
000028  4620              MOV      r0,r4                 ;56
00002a  bd70              POP      {r4-r6,pc}
;;;61     
                          ENDP

                  |L5.44|
                          DCD      ||Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base||
                  |L5.48|
                          DCD      ||Image$$RW_IRAM_DEVICE_APPLICATION$$Limit||

                          AREA ||i.set_devices_state||, CODE, READONLY, ALIGN=2

                  set_devices_state PROC
;;;61     
;;;62     void set_devices_state(u32_t state)
000000  b5f8              PUSH     {r3-r7,lr}
;;;63     {
000002  4605              MOV      r5,r0
;;;64     	struct device *info;
;;;65     
;;;66     	for (info = Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base;
000004  4c09              LDR      r4,|L6.44|
;;;67     				info != Image$$RW_IRAM_DEVICE_APPLICATION$$Limit; info++) {
;;;68     		if (info->config->device_pm_control != device_pm_control_nop) {
000006  4e0a              LDR      r6,|L6.48|
000008  4f0a              LDR      r7,|L6.52|
00000a  e00b              B        |L6.36|
                  |L6.12|
00000c  6820              LDR      r0,[r4,#0]
00000e  6880              LDR      r0,[r0,#8]
000010  42b0              CMP      r0,r6
000012  d006              BEQ      |L6.34|
000014  9500              STR      r5,[sp,#0]
000016  6821              LDR      r1,[r4,#0]
;;;69     			SYS_LOG_DBG("device_name:%s", info->config->name);
;;;70     			SYS_LOG_DBG(",%p", info->config->device_pm_control);
;;;71     			device_set_power_state(info, state);
000018  4620              MOV      r0,r4
00001a  688b              LDR      r3,[r1,#8]
00001c  466a              MOV      r2,sp
00001e  2101              MOVS     r1,#1
000020  4798              BLX      r3
                  |L6.34|
000022  340c              ADDS     r4,r4,#0xc
                  |L6.36|
000024  42bc              CMP      r4,r7                 ;67
000026  d1f1              BNE      |L6.12|
;;;72     		}
;;;73     	}
;;;74     }
000028  bdf8              POP      {r3-r7,pc}
;;;75     
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      ||Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base||
                  |L6.48|
                          DCD      device_pm_control_nop
                  |L6.52|
                          DCD      ||Image$$RW_IRAM_DEVICE_APPLICATION$$Limit||

                          AREA ||.data||, DATA, ALIGN=2

                  config_levels
                          DCD      ||Image$$RW_IRAM_DEVICE_PRE_KERNEL_1$$Base||
                          DCD      ||Image$$RW_IRAM_DEVICE_PRE_KERNEL_2$$Base||
                          DCD      ||Image$$RW_IRAM_DEVICE_POST_KERNEL$$Base||
                          DCD      ||Image$$RW_IRAM_DEVICE_APPLICATION$$Base||
                          DCD      ||Image$$RW_IRAM_DEVICE_APPLICATION$$Limit||

                          AREA ||.device_BUSY||, DATA, ALIGN=0

                  device_busy
                  ||__tagsym$$used||
                          %        8

                          AREA ||.patch_hw_func||, DATA, ALIGN=2

                  __function_patch_device_busy_set
                  |symbol_number.62|
                          DCD      device_busy_set_new
                          DCD      device_busy_set
                  __function_patch_device_busy_clear
                  |symbol_number.64|
                          DCD      device_busy_clear_new
                          DCD      device_busy_clear
