; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave --gnu -o.\objects\bt_host_patch.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\bt_host_patch.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 --preinclude=autoconf_app.h -I..\..\..\..\include -I..\..\..\..\arch -I..\..\..\..\include\arch\arm -I..\..\..\..\include\zephyr -I..\..\..\..\include\net -I..\..\..\..\include\shell -I..\..\..\..\include\drivers -I..\..\..\..\kernel\include -I..\..\..\..\arch\soc\atb110x -I..\..\..\..\include\arch\arm\cortex_m\cmsis\Include -I..\..\..\..\lib\libc\minimal\include -I..\..\..\..\include\generated -I..\..\..\..\boards -I..\src\include -I..\..\..\..\subsys\bluetooth -I..\..\..\..\subsys\bluetooth\host -I..\src\profile -I..\..\gatt -I..\..\..\..\subsys\bluetooth\common -I.\RTE\_flash -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.2.0\Device\ARM\ARMCM0\Include -IF:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=524 -DARMCM0 --omf_browse=.\objects\bt_host_patch.crf ..\..\..\..\subsys\bluetooth\host\bt_host_patch.c]
                          THUMB

                          AREA ||i.atomic_set_bit||, CODE, READONLY, ALIGN=1

                  atomic_set_bit PROC
;;;404     */
;;;405    static inline void atomic_set_bit(atomic_t *target, int bit)
000000  06cb              LSLS     r3,r1,#27
;;;406    {
000002  460a              MOV      r2,r1
;;;407    	atomic_val_t mask = ATOMIC_MASK(bit);
000004  0edb              LSRS     r3,r3,#27
000006  2101              MOVS     r1,#1
000008  4099              LSLS     r1,r1,r3
;;;408    
;;;409    	atomic_or(ATOMIC_ELEM(target, bit), mask);
00000a  0952              LSRS     r2,r2,#5
00000c  b510              PUSH     {r4,lr}               ;406
00000e  0092              LSLS     r2,r2,#2
000010  1810              ADDS     r0,r2,r0
000012  f7fffffe          BL       atomic_or
;;;410    }
000016  bd10              POP      {r4,pc}
;;;411    
                          ENDP


                          AREA ||i.att_cfm_sent_new||, CODE, READONLY, ALIGN=1

                  att_cfm_sent_new PROC
;;;122    
;;;123    void att_cfm_sent_new(struct bt_conn *conn)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125    	struct bt_att *att = att_get(conn);
000002  f7fffffe          BL       att_get
;;;126    
;;;127    	if (att == NULL)
000006  2800              CMP      r0,#0
000008  d002              BEQ      |L2.16|
00000a  30d4              ADDS     r0,r0,#0xd4
;;;128    		return;
;;;129    
;;;130    	k_sem_give(&att->tx_sem);
00000c  f7fffffe          BL       k_sem_give
                  |L2.16|
;;;131    }
000010  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.att_req_sent_new||, CODE, READONLY, ALIGN=2

                  att_req_sent_new PROC
;;;145    
;;;146    void att_req_sent_new(struct bt_conn *conn)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148    	struct bt_att *att = att_get(conn);
000002  f7fffffe          BL       att_get
000006  0004              MOVS     r4,r0
;;;149    
;;;150    	if (att == NULL)
000008  d00d              BEQ      |L3.38|
;;;151    		return;
;;;152    
;;;153    	k_sem_give(&att->tx_sem);
00000a  4620              MOV      r0,r4
00000c  30d4              ADDS     r0,r0,#0xd4
00000e  f7fffffe          BL       k_sem_give
;;;154    
;;;155    	/* Start timeout work */
;;;156    	if (att->req) {
000012  20a0              MOVS     r0,#0xa0
000014  5900              LDR      r0,[r0,r4]
000016  2800              CMP      r0,#0
000018  d005              BEQ      |L3.38|
;;;157    		k_delayed_work_submit(&att->timeout_work, ATT_TIMEOUT);
00001a  4621              MOV      r1,r4
00001c  31ac              ADDS     r1,r1,#0xac
00001e  4a02              LDR      r2,|L3.40|
000020  4802              LDR      r0,|L3.44|
000022  f7fffffe          BL       k_delayed_work_submit_to_queue
                  |L3.38|
;;;158    	}
;;;159    }
000026  bd10              POP      {r4,pc}
;;;160    
                          ENDP

                  |L3.40|
                          DCD      0x00007530
                  |L3.44|
                          DCD      k_sys_work_q

                          AREA ||i.att_rsp_sent_new||, CODE, READONLY, ALIGN=1

                  att_rsp_sent_new PROC
;;;134    
;;;135    void att_rsp_sent_new(struct bt_conn *conn)
000000  b510              PUSH     {r4,lr}
;;;136    {
;;;137    	struct bt_att *att = att_get(conn);
000002  f7fffffe          BL       att_get
;;;138    
;;;139    	if (att == NULL)
000006  2800              CMP      r0,#0
000008  d002              BEQ      |L4.16|
00000a  30d4              ADDS     r0,r0,#0xd4
;;;140    		return;
;;;141    
;;;142    	k_sem_give(&att->tx_sem);
00000c  f7fffffe          BL       k_sem_give
                  |L4.16|
;;;143    }
000010  bd10              POP      {r4,pc}
;;;144    FUNCTION_PATCH_REGISTER(att_rsp_sent, att_rsp_sent_new, att_rsp_sent);
                          ENDP


                          AREA ||i.bt_gatt_clear_ccc||, CODE, READONLY, ALIGN=2

                  bt_gatt_clear_ccc PROC
;;;409    
;;;410    void bt_gatt_clear_ccc(void)
000000  b510              PUSH     {r4,lr}
;;;411    {
;;;412    #ifdef CONFIG_NVRAM_CONFIG
;;;413    	memset(&ccc_save_storage, 0, sizeof(struct ccc_save));
000002  2134              MOVS     r1,#0x34
000004  480a              LDR      r0,|L5.48|
000006  f7fffffe          BL       __aeabi_memclr4
;;;414    	nvram_config_set("BT_CCC", &ccc_save_storage, sizeof(struct ccc_save));
00000a  2234              MOVS     r2,#0x34
00000c  4908              LDR      r1,|L5.48|
00000e  a009              ADR      r0,|L5.52|
000010  f7fffffe          BL       nvram_config_set
;;;415    #endif
;;;416    
;;;417    	bt_gatt_foreach_attr(0x0001, 0xffff, ccc_clear, NULL);
000014  2300              MOVS     r3,#0
000016  4a09              LDR      r2,|L5.60|
000018  4909              LDR      r1,|L5.64|
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       bt_gatt_foreach_attr
;;;418    	SYS_LOG_INF("bt_gatt_clear_ccc");
000020  a308              ADR      r3,|L5.68|
000022  a208              ADR      r2,|L5.68|
000024  a108              ADR      r1,|L5.72|
000026  a00a              ADR      r0,|L5.80|
000028  f7fffffe          BL       printk
;;;419    }
00002c  bd10              POP      {r4,pc}
;;;420    
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      ||.bss||
                  |L5.52|
000034  42545f43          DCB      "BT_CCC",0
000038  434300  
00003b  00                DCB      0
                  |L5.60|
                          DCD      ccc_clear
                  |L5.64|
                          DCD      0x0000ffff
                  |L5.68|
000044  00                DCB      0
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
                  |L5.72|
000048  62745f68          DCB      "bt_host",0
00004c  6f737400
                  |L5.80|
000050  5b25735d          DCB      "[%s] %sbt_gatt_clear_ccc%s\n",0
000054  20257362
000058  745f6761
00005c  74745f63
000060  6c656172
000064  5f636363
000068  25730a00

                          AREA ||i.bt_gatt_load_ccc||, CODE, READONLY, ALIGN=2

                  bt_gatt_load_ccc PROC
;;;372    
;;;373    void bt_gatt_load_ccc(void)
000000  b510              PUSH     {r4,lr}
;;;374    {
;;;375    	ssize_t ret = 0;
;;;376    #ifdef CONFIG_NVRAM_CONFIG
;;;377    	ret = nvram_config_get("BT_CCC", &ccc_save_storage, sizeof(struct ccc_save));
000002  2234              MOVS     r2,#0x34
000004  4909              LDR      r1,|L6.44|
000006  a00a              ADR      r0,|L6.48|
000008  f7fffffe          BL       nvram_config_get
;;;378    #endif
;;;379    	if (ret >= 0)
00000c  2800              CMP      r0,#0
00000e  db06              BLT      |L6.30|
;;;380    		bt_gatt_foreach_attr(0x0001, 0xffff, ccc_load, &ccc_save_storage);
000010  4b06              LDR      r3,|L6.44|
000012  4a09              LDR      r2,|L6.56|
000014  4909              LDR      r1,|L6.60|
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       bt_gatt_foreach_attr
;;;381    	else {
;;;382    		SYS_LOG_INF("bt_gatt_load_ccc failed\n");
;;;383    	}
;;;384    }
00001c  bd10              POP      {r4,pc}
                  |L6.30|
00001e  a308              ADR      r3,|L6.64|
000020  a207              ADR      r2,|L6.64|
000022  a108              ADR      r1,|L6.68|
000024  a009              ADR      r0,|L6.76|
000026  f7fffffe          BL       printk
00002a  bd10              POP      {r4,pc}
;;;385    
                          ENDP

                  |L6.44|
                          DCD      ||.bss||
                  |L6.48|
000030  42545f43          DCB      "BT_CCC",0
000034  434300  
000037  00                DCB      0
                  |L6.56|
                          DCD      ccc_load
                  |L6.60|
                          DCD      0x0000ffff
                  |L6.64|
000040  00                DCB      0
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0
                  |L6.68|
000044  62745f68          DCB      "bt_host",0
000048  6f737400
                  |L6.76|
00004c  5b25735d          DCB      "[%s] %sbt_gatt_load_ccc failed\n%s\n",0
000050  20257362
000054  745f6761
000058  74745f6c
00005c  6f61645f
000060  63636320
000064  6661696c
000068  65640a25
00006c  730a00  
00006f  00                DCB      0

                          AREA ||i.bt_gatt_store_ccc||, CODE, READONLY, ALIGN=2

                  bt_gatt_store_ccc PROC
;;;320    
;;;321    void bt_gatt_store_ccc(bt_addr_le_t *addr, struct ccc_store *p_ccc_store)
000000  b57c              PUSH     {r2-r6,lr}
;;;322    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;323    	int i;
;;;324    
;;;325    	if (bt_addr_le_cmp(addr, &ccc_save_storage.addr)) {
000006  4923              LDR      r1,|L7.148|
000008  2207              MOVS     r2,#7
00000a  f7fffffe          BL       memcmp
00000e  2800              CMP      r0,#0
000010  d008              BEQ      |L7.36|
;;;326    		memset(&ccc_save_storage, 0, sizeof(struct ccc_save));
000012  2134              MOVS     r1,#0x34
000014  481f              LDR      r0,|L7.148|
000016  f7fffffe          BL       __aeabi_memclr4
;;;327    		bt_addr_le_copy(&ccc_save_storage.addr, addr);
00001a  481e              LDR      r0,|L7.148|
00001c  4629              MOV      r1,r5
00001e  2207              MOVS     r2,#7
000020  f7fffffe          BL       __aeabi_memcpy
                  |L7.36|
000024  4a1b              LDR      r2,|L7.148|
;;;328    	}
;;;329    
;;;330    	i = ccc_store_find(p_ccc_store->handle);
000026  8823              LDRH     r3,[r4,#0]
000028  2000              MOVS     r0,#0
00002a  6b11              LDR      r1,[r2,#0x30]
00002c  e005              B        |L7.58|
                  |L7.46|
00002e  0085              LSLS     r5,r0,#2
000030  18ad              ADDS     r5,r5,r2
000032  892d              LDRH     r5,[r5,#8]
000034  429d              CMP      r5,r3
000036  d00a              BEQ      |L7.78|
000038  1c40              ADDS     r0,r0,#1
                  |L7.58|
00003a  4281              CMP      r1,r0
00003c  d8f7              BHI      |L7.46|
00003e  290a              CMP      r1,#0xa
000040  d203              BCS      |L7.74|
000042  4608              MOV      r0,r1
000044  1c49              ADDS     r1,r1,#1
000046  6311              STR      r1,[r2,#0x30]  ; ccc_save_storage
000048  e001              B        |L7.78|
                  |L7.74|
00004a  2000              MOVS     r0,#0
00004c  43c0              MVNS     r0,r0
                  |L7.78|
;;;331    	if ((i >= 0) && (memcmp(&ccc_save_storage.store[i], p_ccc_store, sizeof(struct ccc_store)))) {
00004e  2800              CMP      r0,#0
000050  db1e              BLT      |L7.144|
000052  0080              LSLS     r0,r0,#2
000054  1885              ADDS     r5,r0,r2
000056  4628              MOV      r0,r5
000058  3008              ADDS     r0,r0,#8
00005a  2204              MOVS     r2,#4
00005c  4621              MOV      r1,r4
00005e  f7fffffe          BL       memcmp
000062  2800              CMP      r0,#0
000064  d014              BEQ      |L7.144|
;;;332    		memcpy(&ccc_save_storage.store[i], p_ccc_store, sizeof(struct ccc_store));
000066  8820              LDRH     r0,[r4,#0]
000068  8128              STRH     r0,[r5,#8]
00006a  8860              LDRH     r0,[r4,#2]
00006c  8168              STRH     r0,[r5,#0xa]
;;;333    #ifdef CONFIG_NVRAM_CONFIG
;;;334    		if (nvram_config_set("BT_CCC", &ccc_save_storage, sizeof(struct ccc_save)) >= 0)
00006e  2234              MOVS     r2,#0x34
000070  4908              LDR      r1,|L7.148|
000072  a009              ADR      r0,|L7.152|
000074  f7fffffe          BL       nvram_config_set
000078  2800              CMP      r0,#0
00007a  db09              BLT      |L7.144|
;;;335    			SYS_LOG_INF("Storing CCC: handle 0x%04x value 0x%04x", p_ccc_store->handle, p_ccc_store->value);
00007c  8860              LDRH     r0,[r4,#2]
00007e  a108              ADR      r1,|L7.160|
000080  9101              STR      r1,[sp,#4]
000082  9000              STR      r0,[sp,#0]
000084  8823              LDRH     r3,[r4,#0]
000086  a206              ADR      r2,|L7.160|
000088  a106              ADR      r1,|L7.164|
00008a  a008              ADR      r0,|L7.172|
00008c  f7fffffe          BL       printk
                  |L7.144|
;;;336    #endif
;;;337    	}
;;;338    }
000090  bd7c              POP      {r2-r6,pc}
;;;339    
                          ENDP

000092  0000              DCW      0x0000
                  |L7.148|
                          DCD      ||.bss||
                  |L7.152|
000098  42545f43          DCB      "BT_CCC",0
00009c  434300  
00009f  00                DCB      0
                  |L7.160|
0000a0  00                DCB      0
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L7.164|
0000a4  62745f68          DCB      "bt_host",0
0000a8  6f737400
                  |L7.172|
0000ac  5b25735d          DCB      "[%s] %sStoring CCC: handle 0x%04x value 0x%04x%s\n",0
0000b0  20257353
0000b4  746f7269
0000b8  6e672043
0000bc  43433a20
0000c0  68616e64
0000c4  6c652030
0000c8  78253034
0000cc  78207661
0000d0  6c756520
0000d4  30782530
0000d8  34782573
0000dc  0a00    
0000de  00                DCB      0
0000df  00                DCB      0

                          AREA ||i.ccc_clear||, CODE, READONLY, ALIGN=2

                  ccc_clear PROC
;;;385    
;;;386    static u8_t ccc_clear(const struct bt_gatt_attr *attr, void *user_data)
000000  b57c              PUSH     {r2-r6,lr}
;;;387    {
000002  4605              MOV      r5,r0
;;;388    	struct _bt_gatt_ccc *ccc;
;;;389    	struct bt_gatt_ccc_cfg *cfg;
;;;390    
;;;391    	/* Check if attribute is a CCC */
;;;392    	if (attr->write != bt_gatt_attr_write_ccc) {
000004  6880              LDR      r0,[r0,#8]
000006  4910              LDR      r1,|L8.72|
000008  4288              CMP      r0,r1
00000a  d11a              BNE      |L8.66|
;;;393    		return BT_GATT_ITER_CONTINUE;
;;;394    	}
;;;395    
;;;396    	ccc = attr->user_data;
;;;397    	cfg = &ccc->cfg[0];
00000c  68ec              LDR      r4,[r5,#0xc]
;;;398    
;;;399    	/* Reset value */
;;;400    	if (ccc->cfg_changed && (ccc->value || cfg->value)) {
00000e  68e1              LDR      r1,[r4,#0xc]
000010  6820              LDR      r0,[r4,#0]
000012  2900              CMP      r1,#0
000014  d015              BEQ      |L8.66|
000016  8921              LDRH     r1,[r4,#8]
000018  2900              CMP      r1,#0
00001a  d102              BNE      |L8.34|
00001c  8901              LDRH     r1,[r0,#8]
00001e  2900              CMP      r1,#0
000020  d00f              BEQ      |L8.66|
                  |L8.34|
;;;401    		ccc->value = 0;
000022  2100              MOVS     r1,#0
000024  8121              STRH     r1,[r4,#8]
;;;402    		cfg->value = 0;
000026  8101              STRH     r1,[r0,#8]
;;;403    		ccc->cfg_changed(attr, 0);
000028  68e2              LDR      r2,[r4,#0xc]
00002a  4628              MOV      r0,r5
00002c  4790              BLX      r2
;;;404    		SYS_LOG_INF("reset CCC: handle 0x%04x value 0x%04x", attr->handle, ccc->value);
00002e  8920              LDRH     r0,[r4,#8]
000030  a106              ADR      r1,|L8.76|
000032  9101              STR      r1,[sp,#4]
000034  9000              STR      r0,[sp,#0]
000036  8a2b              LDRH     r3,[r5,#0x10]
000038  a204              ADR      r2,|L8.76|
00003a  a105              ADR      r1,|L8.80|
00003c  a006              ADR      r0,|L8.88|
00003e  f7fffffe          BL       printk
                  |L8.66|
;;;405    	}
;;;406    
;;;407    	return BT_GATT_ITER_CONTINUE;
000042  2001              MOVS     r0,#1
;;;408    }
000044  bd7c              POP      {r2-r6,pc}
;;;409    
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      bt_gatt_attr_write_ccc
                  |L8.76|
00004c  00                DCB      0
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0
                  |L8.80|
000050  62745f68          DCB      "bt_host",0
000054  6f737400
                  |L8.88|
000058  5b25735d          DCB      "[%s] %sreset CCC: handle 0x%04x value 0x%04x%s\n",0
00005c  20257372
000060  65736574
000064  20434343
000068  3a206861
00006c  6e646c65
000070  20307825
000074  30347820
000078  76616c75
00007c  65203078
000080  25303478
000084  25730a00

                          AREA ||i.ccc_load||, CODE, READONLY, ALIGN=2

                  ccc_load PROC
;;;339    
;;;340    static u8_t ccc_load(const struct bt_gatt_attr *attr, void *user_data)
000000  b5fe              PUSH     {r1-r7,lr}
;;;341    {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;342    	struct ccc_save *load = user_data;
;;;343    	struct _bt_gatt_ccc *ccc;
;;;344    	struct bt_gatt_ccc_cfg *cfg;
;;;345    	int i;
;;;346    
;;;347    	/* Check if attribute is a CCC */
;;;348    	if (attr->write != bt_gatt_attr_write_ccc) {
000006  6880              LDR      r0,[r0,#8]
000008  4917              LDR      r1,|L9.104|
00000a  4288              CMP      r0,r1
00000c  d129              BNE      |L9.98|
;;;349    		return BT_GATT_ITER_CONTINUE;
;;;350    	}
;;;351    
;;;352    	/* Clear if value was invalidade */
;;;353    	if (!load->count) {
00000e  6b28              LDR      r0,[r5,#0x30]
000010  2800              CMP      r0,#0
000012  d027              BEQ      |L9.100|
;;;354    		return BT_GATT_ITER_STOP;
;;;355    	}
;;;356    
;;;357    	for (i = 0; i < load->count; i++) {
000014  2400              MOVS     r4,#0
000016  e022              B        |L9.94|
                  |L9.24|
;;;358    		if (load->store[i].handle == attr->handle) {
000018  00a1              LSLS     r1,r4,#2
00001a  1949              ADDS     r1,r1,r5
00001c  8909              LDRH     r1,[r1,#8]
00001e  8a32              LDRH     r2,[r6,#0x10]
000020  4291              CMP      r1,r2
000022  d11b              BNE      |L9.92|
;;;359    			ccc = attr->user_data;
;;;360    			cfg = &ccc->cfg[0];
000024  68f7              LDR      r7,[r6,#0xc]
;;;361    			bt_addr_le_copy(&cfg->peer, &load->addr);
000026  4629              MOV      r1,r5
000028  6838              LDR      r0,[r7,#0]            ;360
00002a  9000              STR      r0,[sp,#0]            ;360
00002c  2207              MOVS     r2,#7                 ;360
00002e  1c40              ADDS     r0,r0,#1              ;360
000030  f7fffffe          BL       __aeabi_memcpy
;;;362    			cfg->value = load->store[i].value;
000034  00a0              LSLS     r0,r4,#2
000036  1944              ADDS     r4,r0,r5
000038  9800              LDR      r0,[sp,#0]
00003a  8961              LDRH     r1,[r4,#0xa]
00003c  8101              STRH     r1,[r0,#8]
;;;363    			ccc->value = cfg->value;
00003e  8139              STRH     r1,[r7,#8]
;;;364    			ccc->cfg_changed(attr, ccc->value);
000040  68fa              LDR      r2,[r7,#0xc]
000042  4630              MOV      r0,r6
000044  4790              BLX      r2
;;;365    			SYS_LOG_INF("Restoring CCC: handle 0x%04x value 0x%04x", load->store[i].handle, load->store[i].value);
000046  8960              LDRH     r0,[r4,#0xa]
000048  a108              ADR      r1,|L9.108|
00004a  9101              STR      r1,[sp,#4]
00004c  9000              STR      r0,[sp,#0]
00004e  8923              LDRH     r3,[r4,#8]
000050  a206              ADR      r2,|L9.108|
000052  a107              ADR      r1,|L9.112|
000054  a008              ADR      r0,|L9.120|
000056  f7fffffe          BL       printk
;;;366    			break;
00005a  e002              B        |L9.98|
                  |L9.92|
00005c  1c64              ADDS     r4,r4,#1
                  |L9.94|
00005e  42a0              CMP      r0,r4                 ;357
000060  d8da              BHI      |L9.24|
                  |L9.98|
;;;367    		}
;;;368    	}
;;;369    
;;;370    	return BT_GATT_ITER_CONTINUE;
000062  2001              MOVS     r0,#1
                  |L9.100|
;;;371    }
000064  bdfe              POP      {r1-r7,pc}
;;;372    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      bt_gatt_attr_write_ccc
                  |L9.108|
00006c  00                DCB      0
00006d  00                DCB      0
00006e  00                DCB      0
00006f  00                DCB      0
                  |L9.112|
000070  62745f68          DCB      "bt_host",0
000074  6f737400
                  |L9.120|
000078  5b25735d          DCB      "[%s] %sRestoring CCC: handle 0x%04x value 0x%04x%s\n",0
00007c  20257352
000080  6573746f
000084  72696e67
000088  20434343
00008c  3a206861
000090  6e646c65
000094  20307825
000098  30347820
00009c  76616c75
0000a0  65203078
0000a4  25303478
0000a8  25730a00

                          AREA ||i.gatt_ccc_changed_new||, CODE, READONLY, ALIGN=1

                  gatt_ccc_changed_new PROC
;;;420    
;;;421    void gatt_ccc_changed_new(const struct bt_gatt_attr *attr, struct _bt_gatt_ccc *ccc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;422    {
000002  460d              MOV      r5,r1
;;;423    	int i;
;;;424    	u16_t value = 0x0000;
000004  2400              MOVS     r4,#0
000006  4606              MOV      r6,r0                 ;422
;;;425    
;;;426    	for (i = 0; i < ccc->cfg_len; i++) {
000008  4622              MOV      r2,r4
00000a  6849              LDR      r1,[r1,#4]
00000c  e007              B        |L10.30|
                  |L10.14|
;;;427    		if (ccc->cfg[i].value > value) {
00000e  0110              LSLS     r0,r2,#4
000010  682b              LDR      r3,[r5,#0]
000012  3008              ADDS     r0,r0,#8
000014  5a18              LDRH     r0,[r3,r0]
000016  42a0              CMP      r0,r4
000018  d900              BLS      |L10.28|
;;;428    			value = ccc->cfg[i].value;
00001a  4604              MOV      r4,r0
                  |L10.28|
00001c  1c52              ADDS     r2,r2,#1
                  |L10.30|
00001e  4291              CMP      r1,r2                 ;426
000020  d8f5              BHI      |L10.14|
;;;429    		}
;;;430    	}
;;;431    
;;;432    	if (value != ccc->value) {
000022  8928              LDRH     r0,[r5,#8]
000024  42a0              CMP      r0,r4
000026  d012              BEQ      |L10.78|
;;;433    		ccc->value = value;
000028  812c              STRH     r4,[r5,#8]
;;;434    		ccc->cfg_changed(attr, value);
00002a  68ea              LDR      r2,[r5,#0xc]
00002c  4621              MOV      r1,r4
00002e  4630              MOV      r0,r6
000030  4790              BLX      r2
;;;435    		if (bt_addr_le_is_bonded(&ccc->cfg[0].peer)) {
000032  6828              LDR      r0,[r5,#0]
000034  1c40              ADDS     r0,r0,#1
000036  f7fffffe          BL       bt_addr_le_is_bonded
00003a  2800              CMP      r0,#0
00003c  d007              BEQ      |L10.78|
;;;436    			struct ccc_store ccc_store_tmp;
;;;437    
;;;438    			ccc_store_tmp.handle = attr->handle;
00003e  8a30              LDRH     r0,[r6,#0x10]
000040  4669              MOV      r1,sp
000042  8008              STRH     r0,[r1,#0]
;;;439    			ccc_store_tmp.value = value;
000044  804c              STRH     r4,[r1,#2]
;;;440    			bt_gatt_store_ccc(&ccc->cfg[0].peer, &ccc_store_tmp);
000046  6828              LDR      r0,[r5,#0]
000048  1c40              ADDS     r0,r0,#1
00004a  f7fffffe          BL       bt_gatt_store_ccc
                  |L10.78|
;;;441    		}
;;;442    	}
;;;443    }
00004e  bdf8              POP      {r3-r7,pc}
;;;444    
                          ENDP


                          AREA ||i.hci_set_le_local_feat||, CODE, READONLY, ALIGN=2

                  hci_set_le_local_feat PROC
;;;487    
;;;488    void hci_set_le_local_feat(u8_t feat, u8_t flag)
000000  b53e              PUSH     {r1-r5,lr}
;;;489    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;490    	struct net_buf *rsp;
;;;491    	int err;
;;;492    	local_feat_t feature;
;;;493    
;;;494    	/* Read Low Energy Supported Features */
;;;495    	err = bt_hci_cmd_send_sync(BT_HCI_OP_LE_READ_LOCAL_FEATURES, NULL,
000006  aa02              ADD      r2,sp,#8
000008  2100              MOVS     r1,#0
00000a  4815              LDR      r0,|L11.96|
00000c  f7fffffe          BL       bt_hci_cmd_send_sync
;;;496    				 &rsp);
;;;497    	if (err) {
000010  2800              CMP      r0,#0
000012  d006              BEQ      |L11.34|
;;;498    		SYS_LOG_INF("read le feature failed\n");
000014  a313              ADR      r3,|L11.100|
000016  a213              ADR      r2,|L11.100|
000018  a113              ADR      r1,|L11.104|
00001a  a015              ADR      r0,|L11.112|
00001c  f7fffffe          BL       printk
                  |L11.32|
;;;499    		return;
;;;500    	} else {
;;;501    		struct bt_hci_rp_le_read_local_features *rp = (void *)rsp->data;
;;;502    
;;;503    		if (rp->status)
;;;504    			return;
;;;505    		memcpy(&feature, rp->features, sizeof(local_feat_t));
;;;506    	}
;;;507    
;;;508    	if (flag) {
;;;509    		/* set feature bit */
;;;510    		feature.val[(feat) >> 3] |= BIT((feat) & 7);
;;;511    	} else {
;;;512    		/* clear feature bit */
;;;513    		feature.val[(feat) >> 3] &= ~BIT((feat) & 7);
;;;514    	}
;;;515    
;;;516    	hci_vs_set_local_feat(&feature);
;;;517    
;;;518    	net_buf_unref(rsp);
;;;519    }
000020  bd3e              POP      {r1-r5,pc}
                  |L11.34|
000022  9802              LDR      r0,[sp,#8]            ;501
000024  6881              LDR      r1,[r0,#8]            ;503
000026  7808              LDRB     r0,[r1,#0]            ;503
000028  2800              CMP      r0,#0                 ;503
00002a  d1f9              BNE      |L11.32|
00002c  2208              MOVS     r2,#8                 ;505
00002e  4668              MOV      r0,sp                 ;505
000030  1c49              ADDS     r1,r1,#1              ;505
000032  f7fffffe          BL       __aeabi_memcpy
000036  0768              LSLS     r0,r5,#29             ;510
000038  0f40              LSRS     r0,r0,#29             ;510
00003a  2101              MOVS     r1,#1                 ;510
00003c  4081              LSLS     r1,r1,r0              ;510
00003e  466a              MOV      r2,sp                 ;492
000040  08e8              LSRS     r0,r5,#3              ;510
000042  5c13              LDRB     r3,[r2,r0]            ;513
000044  2c00              CMP      r4,#0                 ;508
000046  d001              BEQ      |L11.76|
000048  430b              ORRS     r3,r3,r1              ;510
00004a  e000              B        |L11.78|
                  |L11.76|
00004c  438b              BICS     r3,r3,r1              ;513
                  |L11.78|
00004e  5413              STRB     r3,[r2,r0]            ;513
000050  4610              MOV      r0,r2                 ;516
000052  f7fffffe          BL       hci_vs_set_local_feat
000056  9802              LDR      r0,[sp,#8]            ;518
000058  f7fffffe          BL       net_buf_unref
00005c  bd3e              POP      {r1-r5,pc}
;;;520    
                          ENDP

00005e  0000              DCW      0x0000
                  |L11.96|
                          DCD      0x00002003
                  |L11.100|
000064  00                DCB      0
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L11.104|
000068  62745f68          DCB      "bt_host",0
00006c  6f737400
                  |L11.112|
000070  5b25735d          DCB      "[%s] %sread le feature failed\n%s\n",0
000074  20257372
000078  65616420
00007c  6c652066
000080  65617475
000084  72652066
000088  61696c65
00008c  640a2573
000090  0a00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.hci_vs_set_local_feat||, CODE, READONLY, ALIGN=2

                  hci_vs_set_local_feat PROC
;;;462    
;;;463    int hci_vs_set_local_feat(local_feat_t *feat)
000000  b5f8              PUSH     {r3-r7,lr}
;;;464    {
;;;465    	int err;
;;;466    	struct net_buf *buf;
;;;467    	u8_t *p;
;;;468    
;;;469    	buf = bt_hci_cmd_create(LE_EXT_OPCODE_VS_SET_LOCAL_FEAT,
000002  4d13              LDR      r5,|L12.80|
000004  4606              MOV      r6,r0                 ;464
000006  2108              MOVS     r1,#8
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       bt_hci_cmd_create
00000e  0004              MOVS     r4,r0
;;;470    				sizeof(local_feat_t));
;;;471    	if (!buf) {
000010  d018              BEQ      |L12.68|
;;;472    		return -ENOBUFS;
;;;473    	}
;;;474    
;;;475    	p = net_buf_add(buf, sizeof(local_feat_t));
000012  2108              MOVS     r1,#8
000014  1860              ADDS     r0,r4,r1
000016  f7fffffe          BL       net_buf_simple_add
;;;476    
;;;477    	memcpy(p, feat, sizeof(local_feat_t));
00001a  2208              MOVS     r2,#8
00001c  4631              MOV      r1,r6
00001e  f7fffffe          BL       __aeabi_memcpy
;;;478    
;;;479    	err = bt_hci_cmd_send_sync(LE_EXT_OPCODE_VS_SET_LOCAL_FEAT, buf,
000022  2200              MOVS     r2,#0
000024  4621              MOV      r1,r4
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       bt_hci_cmd_send_sync
00002c  0004              MOVS     r4,r0
;;;480    				   NULL);
;;;481    	if (err) {
00002e  d00c              BEQ      |L12.74|
;;;482    		SYS_LOG_ERR("set local feature failed %d\n", err);
000030  a008              ADR      r0,|L12.84|
000032  9000              STR      r0,[sp,#0]
000034  4623              MOV      r3,r4
000036  a207              ADR      r2,|L12.84|
000038  a107              ADR      r1,|L12.88|
00003a  a009              ADR      r0,|L12.96|
00003c  f7fffffe          BL       printk
;;;483    		return err;
000040  4620              MOV      r0,r4
;;;484    	}
;;;485    	return 0;
;;;486    }
000042  bdf8              POP      {r3-r7,pc}
                  |L12.68|
000044  2036              MOVS     r0,#0x36              ;472
000046  43c0              MVNS     r0,r0                 ;472
000048  bdf8              POP      {r3-r7,pc}
                  |L12.74|
00004a  2000              MOVS     r0,#0                 ;485
00004c  bdf8              POP      {r3-r7,pc}
;;;487    
                          ENDP

00004e  0000              DCW      0x0000
                  |L12.80|
                          DCD      0x0000fff2
                  |L12.84|
000054  00                DCB      0
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L12.88|
000058  62745f68          DCB      "bt_host",0
00005c  6f737400
                  |L12.96|
000060  5b25735d          DCB      "[%s] %sset local feature failed %d\n%s\n",0
000064  20257373
000068  6574206c
00006c  6f63616c
000070  20666561
000074  74757265
000078  20666169
00007c  6c656420
000080  25640a25
000084  730a00  
000087  00                DCB      0

                          AREA ||i.le_conn_update_new||, CODE, READONLY, ALIGN=2

                  le_conn_update_new PROC
;;;65     
;;;66     void le_conn_update_new(struct k_work *work)
000000  b57c              PUSH     {r2-r6,lr}
;;;67     {
000002  4604              MOV      r4,r0
000004  3c74              SUBS     r4,r4,#0x74
;;;68     	struct bt_conn_le *le = CONTAINER_OF(work, struct bt_conn_le,
;;;69     					     update_work);
;;;70     	struct bt_conn *conn = CONTAINER_OF(le, struct bt_conn, le);
;;;71     	const struct bt_le_conn_param *param;
;;;72     
;;;73     	if (conn->state == BT_CONN_CONNECT) {
000006  7b20              LDRB     r0,[r4,#0xc]
000008  2802              CMP      r0,#2
00000a  d007              BEQ      |L13.28|
;;;74     		bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
;;;75     		return;
;;;76     	}
;;;77     
;;;78     	if (app_ready_update && !app_ready_update() && (update_delay_times++ < 30)) {
00000c  4d15              LDR      r5,|L13.100|
00000e  6868              LDR      r0,[r5,#4]  ; app_ready_update
000010  2800              CMP      r0,#0
000012  d011              BEQ      |L13.56|
000014  4780              BLX      r0
000016  2800              CMP      r0,#0
000018  d005              BEQ      |L13.38|
00001a  e00d              B        |L13.56|
                  |L13.28|
00001c  2113              MOVS     r1,#0x13              ;74
00001e  4620              MOV      r0,r4                 ;74
000020  f7fffffe          BL       bt_conn_disconnect
;;;79     		update_conn_param(conn);
;;;80     		return;
;;;81     	}
;;;82     
;;;83     	update_delay_times = 0;
;;;84     
;;;85     	if (p_update_cfg) {
;;;86     		param = (const struct bt_le_conn_param *)p_update_cfg;
;;;87     	} else {
;;;88     		param = BT_LE_CONN_PARAM(conn->le.interval_min,
;;;89     					 conn->le.interval_max,
;;;90     					 conn->le.latency,
;;;91     					 conn->le.timeout);
;;;92     	}
;;;93     
;;;94     	bt_conn_le_param_update(conn, param);
;;;95     }
000024  bd7c              POP      {r2-r6,pc}
                  |L13.38|
000026  7828              LDRB     r0,[r5,#0]            ;78  ; update_delay_times
000028  1c41              ADDS     r1,r0,#1              ;78
00002a  7029              STRB     r1,[r5,#0]            ;78
00002c  281e              CMP      r0,#0x1e              ;78
00002e  d203              BCS      |L13.56|
000030  4620              MOV      r0,r4                 ;79
000032  f7fffffe          BL       update_conn_param
000036  bd7c              POP      {r2-r6,pc}
                  |L13.56|
000038  2000              MOVS     r0,#0                 ;83
00003a  7028              STRB     r0,[r5,#0]            ;83
00003c  480a              LDR      r0,|L13.104|
00003e  6801              LDR      r1,[r0,#0]            ;85  ; p_update_cfg
000040  2900              CMP      r1,#0                 ;85
000042  d10b              BNE      |L13.92|
000044  4620              MOV      r0,r4                 ;88
000046  3040              ADDS     r0,r0,#0x40           ;88
000048  8c01              LDRH     r1,[r0,#0x20]         ;88
00004a  466a              MOV      r2,sp                 ;88
00004c  8011              STRH     r1,[r2,#0]            ;88
00004e  8c41              LDRH     r1,[r0,#0x22]         ;88
000050  8051              STRH     r1,[r2,#2]            ;88
000052  8c81              LDRH     r1,[r0,#0x24]         ;88
000054  8091              STRH     r1,[r2,#4]            ;88
000056  8cc0              LDRH     r0,[r0,#0x26]         ;88
000058  80d0              STRH     r0,[r2,#6]            ;88
00005a  4669              MOV      r1,sp                 ;88
                  |L13.92|
00005c  4620              MOV      r0,r4                 ;94
00005e  f7fffffe          BL       bt_conn_le_param_update
000062  bd7c              POP      {r2-r6,pc}
;;;96     
                          ENDP

                  |L13.100|
                          DCD      ||.data||
                  |L13.104|
                          DCD      p_update_cfg

                          AREA ||i.register_app_ready_update_cback||, CODE, READONLY, ALIGN=2

                  register_app_ready_update_cback PROC
;;;45     
;;;46     void register_app_ready_update_cback(app_ready_update_t app_ready_func)
000000  4901              LDR      r1,|L14.8|
;;;47     {
;;;48     	app_ready_update = app_ready_func;
000002  6048              STR      r0,[r1,#4]  ; app_ready_update
;;;49     }
000004  4770              BX       lr
;;;50     
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.smp_reset_new||, CODE, READONLY, ALIGN=2

                  smp_reset_new PROC
;;;259    
;;;260    void smp_reset_new(struct bt_smp *smp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;261    {
;;;262    	struct bt_conn *conn = smp->chan.chan.conn;
;;;263    
;;;264    	if (atomic_test_bit(smp->flags, SMP_FLAG_BOND)) {
000002  4606              MOV      r6,r0
000004  4604              MOV      r4,r0                 ;261
000006  36a0              ADDS     r6,r6,#0xa0
000008  6805              LDR      r5,[r0,#0]
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       atomic_get
000010  1280              ASRS     r0,r0,#10
000012  07c0              LSLS     r0,r0,#31
000014  0fc0              LSRS     r0,r0,#31
000016  d008              BEQ      |L15.42|
;;;265    		struct bt_keys *keys = smp->chan.chan.conn->le.keys;
;;;266    
;;;267    		bt_storage->write(&keys->addr, BT_STORAGE_BT_KEYS, (void *)keys, sizeof(struct bt_keys));
000018  4914              LDR      r1,|L15.108|
00001a  6820              LDR      r0,[r4,#0]            ;265
00001c  6809              LDR      r1,[r1,#0]  ; bt_storage
00001e  6f00              LDR      r0,[r0,#0x70]         ;265
000020  2390              MOVS     r3,#0x90
000022  684f              LDR      r7,[r1,#4]
000024  4602              MOV      r2,r0
000026  2109              MOVS     r1,#9
000028  47b8              BLX      r7
                  |L15.42|
;;;268    	}
;;;269    
;;;270    	k_delayed_work_cancel(&smp->work);
00002a  4620              MOV      r0,r4
00002c  30ff              ADDS     r0,r0,#0xff
00002e  307d              ADDS     r0,r0,#0x7d
000030  f7fffffe          BL       k_delayed_work_cancel
;;;271    
;;;272    	smp->method = JUST_WORKS;
000034  2000              MOVS     r0,#0
000036  7130              STRB     r0,[r6,#4]
;;;273    	atomic_set(&smp->allowed_cmds, 0);
000038  4601              MOV      r1,r0
00003a  4620              MOV      r0,r4
00003c  309c              ADDS     r0,r0,#0x9c
00003e  4604              MOV      r4,r0
000040  f7fffffe          BL       atomic_set
;;;274    	atomic_set(smp->flags, 0);
000044  2100              MOVS     r1,#0
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       atomic_set
;;;275    
;;;276    	if (conn->required_sec_level != conn->sec_level) {
00004c  7a69              LDRB     r1,[r5,#9]
00004e  7a28              LDRB     r0,[r5,#8]
000050  4281              CMP      r1,r0
000052  d000              BEQ      |L15.86|
;;;277    		/* TODO report error */
;;;278    		/* reset required security level in case of error */
;;;279    		conn->required_sec_level = conn->sec_level;
000054  7268              STRB     r0,[r5,#9]
                  |L15.86|
;;;280    	}
;;;281    
;;;282    	if (conn->role == BT_HCI_ROLE_MASTER) {
000056  78e8              LDRB     r0,[r5,#3]
000058  2800              CMP      r0,#0
00005a  d004              BEQ      |L15.102|
;;;283    		atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_SECURITY_REQUEST);
;;;284    		return;
;;;285    	}
;;;286    
;;;287    	atomic_set_bit(&smp->allowed_cmds, BT_SMP_CMD_PAIRING_REQ);
00005c  2101              MOVS     r1,#1
                  |L15.94|
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       atomic_set_bit
;;;288    }
000064  bdf8              POP      {r3-r7,pc}
                  |L15.102|
000066  210b              MOVS     r1,#0xb               ;283
000068  e7f9              B        |L15.94|
;;;289    
                          ENDP

00006a  0000              DCW      0x0000
                  |L15.108|
                          DCD      bt_storage

                          AREA ||i.update_conn_param_new||, CODE, READONLY, ALIGN=2

                  update_conn_param_new PROC
;;;51     
;;;52     void update_conn_param_new(struct bt_conn *conn)
000000  b510              PUSH     {r4,lr}
;;;53     {
;;;54     	/*
;;;55     	 * Core 4.2 Vol 3, Part C, 9.3.12.2
;;;56     	 * The Peripheral device should not perform a Connection Parameter
;;;57     	 * Update procedure within 5 s after establishing a connection.
;;;58     	 */
;;;59     	k_delayed_work_submit(&conn->le.update_work,
000002  4601              MOV      r1,r0
000004  78c0              LDRB     r0,[r0,#3]
000006  3174              ADDS     r1,r1,#0x74
000008  2800              CMP      r0,#0
00000a  d005              BEQ      |L16.24|
;;;60     				 conn->role == BT_HCI_ROLE_MASTER ? K_NO_WAIT :
;;;61     				 bt_conn_update_timeout);
00000c  4803              LDR      r0,|L16.28|
00000e  6802              LDR      r2,[r0,#0]  ; bt_conn_update_timeout
                  |L16.16|
000010  4803              LDR      r0,|L16.32|
000012  f7fffffe          BL       k_delayed_work_submit_to_queue
;;;62     }
000016  bd10              POP      {r4,pc}
                  |L16.24|
000018  2200              MOVS     r2,#0                 ;60
00001a  e7f9              B        |L16.16|
;;;63     
                          ENDP

                  |L16.28|
                          DCD      bt_conn_update_timeout
                  |L16.32|
                          DCD      k_sys_work_q

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ccc_save_storage
                          %        52

                          AREA ||.data||, DATA, ALIGN=2

                  update_delay_times
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  app_ready_update
                          DCD      0x00000000

                          AREA ||.patch_hw_code||, DATA, ALIGN=2

                  __code_patch_le_conn_update
                  ||__tagsym$$used||
                          DCD      le_conn_update_new
                          DCD      0x0001859c
                  __code_patch_att_req_sent
                  |symbol_number.138|
                          DCD      att_req_sent_new
                          DCD      0x0001af48
                  __code_patch_hciVsCb_cfgNext_nop
                  |symbol_number.140|
                          DCD      0x33008aa3
                          DCD      0x00017b84
                  __code_patch_ccc_cfg_valid
                  |symbol_number.142|
                          DCD      0x2300d003
                          DCD      0x0001c9d8

                          AREA ||.patch_hw_func||, DATA, ALIGN=2

                  __function_patch_update_conn_param
                  |symbol_number.144|
                          DCD      update_conn_param_new
                          DCD      update_conn_param
                  __function_patch_att_cfm_sent
                  |symbol_number.146|
                          DCD      att_cfm_sent_new
                          DCD      att_cfm_sent
                  __function_patch_att_rsp_sent
                  |symbol_number.148|
                          DCD      att_rsp_sent_new
                          DCD      att_rsp_sent
                  __function_patch_smp_reset
                  |symbol_number.150|
                          DCD      smp_reset_new
                          DCD      smp_reset
                  __function_patch_gatt_ccc_changed
                  |symbol_number.152|
                          DCD      gatt_ccc_changed_new
                          DCD      gatt_ccc_changed
